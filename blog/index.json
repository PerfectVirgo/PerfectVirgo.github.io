[
    {
        "ref": "http://dongshuaizhi.top/blog/16-js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/",
        "title": "JS对象基本用法",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.11",
        "body": "1. 对象   定义\n无序的数据集合\n键值对的集合\n  写法\nlet obj = { 'name': 'frank', 'age': 18 }\nlet obj = new Object({ 'name': 'frank' })\nconsole.log({ 'name': 'frank', 'age': 18 })\n  细节\n键名是字符串，不是标识符，可以包含任意字符\n引号可省略，省略之后就只能写标识符\n就算引号省略了，键名也还是字符串（重要）\n  属性名\n每个 key 都是对象的属性名（property）\n  属性值\n每个 value 都是对象的属性值\n  奇怪的属性名\n  所有属性名会自动变成字符串\nlet obj = {\r1: \u0026#39;a\u0026#39;,\r3.2: \u0026#39;b\u0026#39;,\r1e2: true,\r1e-2: true,\r.234: true,\r0xFF: true\r};\rObject.keys(obj)\r=\u0026gt;[\u0026#34;1\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;255\u0026#34;,\u0026#34;3.2\u0026#34;,\u0026#34;0.01\u0026#34;,\u0026#34;0.234\u0026#34;]\r  细节\nObject.keys(obj) 可以得到 obj 的所有 key\n    变量做属性名\n  如何用变量做属性名\n之前都是用常量做属性名\nlet p1 = 'name'\nlet obj = { p1: 'frank' } 这样写，属性名为 \u0026lsquo;p1\u0026rsquo;\nlet obj = { [p1]: 'frank' } 这样写，属性名为 \u0026lsquo;name\u0026rsquo;\n  对比\n不加 [] 的属性名会自动变成字符串\n加了 [] 则会当做变量求值\n值如果不是字符串，则会自动变成字符串\n    对象的隐藏属性\n  隐藏属性\nJS 中每一个对象都有一个隐藏属性\n这个隐藏属性储存着其共有属性组成的对象的地址\n这个共有属性组成的对象叫做原型\n也就是说，隐藏属性储存着原型的地址\n  代码示例\nvar obj = {}\robj.toString()\t// 居然不报错\r因为 obj 的隐藏属性对应的对象上有 toString()\n    超纲知识\n  除了字符串，symbol 也能做属性名\nlet a = Symbol()\rlet obj = { [a]: \u0026#39;Hello\u0026#39; }\r  这有什么用呢？\n目前，屁用都没有，很久很久以后会有用\n在学习【迭代】时会用到\n    2. 对象属性的增删改查   删除属性\n  delete obj.xxx 或 delete obj['xxx']\n即可删除 obj 的 xxx 属性\n请区分【属性值为 undefined】和 【不含属性名】\n  不含属性名\n'xxx' in obj === false\n  含有属性名，但是值为 undefined\n'xxx' in obj === true \u0026amp;\u0026amp; obj.xxx === undefined\n  注意 obj.xxx === undefined\n不能断定 \u0026lsquo;xxx\u0026rsquo; 是否为 obj 的属性\n  类比\n你有没有卫生纸？\nA：没有\t// 不含属性名\nB：有，但是没带\t// 含有属性名，但是值为 undefined\n  程序员就是这么严谨\n没有就是没有，undefined 就是 undefined，绝不含糊\n    查看所有属性（读属性）\n  查看自身所有属性\nObject.keys(obj)：可以查所有的 key\nObject.values(obj)：可以查所有的 value\nObject.entries(obj)：可以查所有的 key 和 value\n  查看自身 + 共有属性\nconsole.dir(obj)\n  判断一个属性是自身的还是共有的\nobj.hasOwnProperty('toString')\n    原型\n  每个对象都有原型\n原型里存着对象的共有属性\n比如 obj 的原型就是一个对象\nobj.__proto__ 存着这个对象的地址\n这个对象里有 toString / constructor / valueOf 等属性\n  对象的原型也是对象\n所以对象的原型也有原型\nobj = {} 的原型即为所有对象的原型\n这个原型包含所有对象的共有属性，是对象的根\n这个原型也有原型，是 null\n    查看属性\n  两种方法查看属性\n中括号语法：obj['key']\n点语法：obj.key\n坑新人语法：obj[key]\t//变量 key 值一般不为 'key'\n示例：\nvar obj = { name: \u0026#39;frank\u0026#39;, age: 18 }\robj[\u0026#39;name\u0026#39;]\t// \u0026#34;frank\u0026#34;\robj.name\t// \u0026#34;frank\u0026#34;\robj[name]\t// undefined，默认每一个 window 的 name 都是空字符串\rname\t// \u0026#34;\u0026#34;\r window.name = \u0026#39;age\u0026#39;\robj[name]\r// 18，因为 name 是全局变量，全局变量也是 window 的属性，这是 JS 的奇葩设定，所以如果中括号里是变量，必须先求变量的值\rname\t// \u0026#34;age\u0026#34;\r obj[\u0026#39;na\u0026#39;+\u0026#39;me\u0026#39;]\t// \u0026#34;frank\u0026#34;\robj[console.log(\u0026#39;name\u0026#39;)]\r// undefined，因为 log 返回的值永远是 undefined，所以相当于obj[\u0026#39;undefined\u0026#39;]，而 obj 是没有这个 key 的，所以最后得到 undefined\r总结：读对象的属性时， 如果使用 [ ] 语法，那么 JS 会先求 [ ] 中表达式的值，注意区分表达式是变量还是常量。 如果使用点语法，那么点后面一定是 string 常量。\n  请优先使用中括号语法\n点语法会误导你，让你以为 key 不是字符串\n等你确定不会弄混两种语法，再改用点语法\n  obj.name 等价于 obj['name']\nobj.name 不等价于 obj[name]\n简单来说，. 后面的 name 是字符串，而不是变量\n  let name = 'frank'\nobj[name] 等价于 obj['frank'] 而不是 obj['name'] 和 obj.name\n  考题\n代码：\nlet list = [ \u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39; ]\rlet person = { name: \u0026#39;frank\u0026#39;, age: 18, gender: \u0026#39;man\u0026#39; }\rfor (let i = 0; i \u0026lt; list.length; i++) {\rlet name = list[i];\rconsole.log(person__???__)\r}\r// 使得 person 的所有属性被打印出来\r选项：（B）\nA. console.log(person.name)\nB. console.log(person[name])\n    修改或增加属性（写属性）\n  直接赋值\nlet obj = { name: \u0026#39;frank\u0026#39; }\t// name 是字符串\robj.name = \u0026#39;frank\u0026#39;\t// name 是字符串\robj[\u0026#39;name\u0026#39;] = \u0026#39;frank\u0026#39;\robj[name] = \u0026#39;frank\u0026#39;\t// 错，因 name 值不确定\r obj[\u0026#39;na\u0026#39;+\u0026#39;me\u0026#39;] = \u0026#39;frank\u0026#39;\rlet key = \u0026#39;name\u0026#39;;\robj[key] = \u0026#39;frank\u0026#39;\rlet key = \u0026#39;name\u0026#39;;\robj.key = \u0026#39;frank\u0026#39;\t// 错，因为 obj.key 等价于 obj[\u0026#39;key\u0026#39;]\r  批量赋值\nObject.assign(obj, { age: 18, gender: 'man' })\n    修改或增加共有属性\n  无法通过自身修改或增加共有属性\nlet obj = {}, obj2 = {}\t// 共有 toString\nobj.tostring = 'xxx' 只会在改 obj 自身属性\nobj2.toString 还是在原型上\n在读的时候会去看你的隐藏属性对应的原型，写的时候不走原型，写的时候只能写到自己身上\n  我偏要修改或增加原型上的属性\nobj.__proto__.toString = 'xxx'\t// 不推荐用__proto__ ,所有__proto__代码都是强烈不推荐写的\nObject.prototype.toString = 'xxx'\n一般来说，不要修改原型，会引起很多问题\n    修改隐藏属性\n  不推荐使用 __proto__\nlet obj = { name: \u0026#39;frank\u0026#39; }\rlet obj2 = { name: \u0026#39;jack\u0026#39; }\rlet common = { kind: \u0026#39;human\u0026#39; }\robj.__proto__ = common\robj2.__proto__ = common\r  推荐使用 Object.create\nlet obj = Object.create(common)\robj.name = \u0026#39;frank\u0026#39;\rlet obj2 = Object.create(common)\robj2.name = \u0026#39;jack\u0026#39;\r规范大概的意思是，要改就一开始就改，别后来再改\n  用内存图理解\n  var obj = Object.create({ name: 'frank' })\n与 var obj2 = new Object({ name: 'frank' }) 的区别\n答：前者的属性是写在原型上的，后者的属性是写在自身上的，具体如图\n    "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/",
        "title": "数据类型和运算符",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.10",
        "body": "1. 数字与字符串   都是一，为什么要分 1 和 \u0026lsquo;1\u0026rsquo;\n  功能不同\n数字是数字，字符串是字符串，要严谨\n数字能加减乘除，字符串不行\n字符串能表示电话号码，数字不行\n  存储形式不同\nJS 中，数字是用 64 位浮点数的形式存储的\nJS 中，字符串是用类似 UTF8 形式存储的（UCS-2）\n  2. 如何存数字   十进制转二进制即可\n  二进制\n  10 转 2\n31 变成二进制\t经过一番尝试\t所以 31（十进制) = 11111（二进制）\n不是套公式吗？程序员从来不套公式\n  2 转 10\n100011 变成十进制\n每一位乘以 2 的 N 次方，然后加起来即可\n100011 = 2^5 + 2^1 + 2^0 = 35\n    用十六进制表示二进制\n  为什么用十六进制\n因为二进制写起来太慢了：011110001011010\n记住 8 4 2 1 对应 X X X X\n从右往左每四位改写成一位：011110001011010\n得到 3，12，5，10；把大于 9 的数字改为 ABCDEF\n于是得到 3C5A，你也可以用计算器的程序员模式\nHEX 表示 16 进制，BIN 表示 2 进制\nOCT 表示 8 进制，DEC 表示 10 进制\n    3. 如何存字符   转成数字不就得了\n但是注意，\u0026lsquo;1\u0026rsquo; 不能用 1 来表示\n  啥是 UTF8\n说来话长\n  如何存储 a b c 1 2 3\n简单，编号表示\n  用 0 ~ 127 表示所有符号\n 0 表示结束字符 10 表示换行 13 表示回车 32 表示空格 33 到 47 表示标点 48 到 57 表示数字符号 65 到 90 表示大写字母 97 到 122 表示小写字母 127 表示删除键    中国人开始用电脑了\n怎么表示中文呢\n  简单，还是编号\n中国国家标准局来编，名称为【国标2312】\n  用 000 ~ FFFF 表示汉字\n 一个 16 进制数是 4 个 0/1 位 FFFF 就是 4x4=16 位，也就是两个字节 最多收录 2^16 = 65536 个字符 但只收录了 6000 多汉字、西文字母和日文假名 【你】的 GB2312 编号为 C4E3 【牛】的 GB2312 编号为 C5A3    中国人的名字里有生僻字！\neg：李讞 =\u0026gt; 李* 陶喆 =\u0026gt; 陶吉吉\n怎么表示生僻字、繁体字、韩文呢，之前的忘了编进去\n  微软出手了\n微软推出了一个国标扩展，简称 GBK\n  GBK 国标扩\n 含 21886 个汉字和图形符号 收录了中日韩使用的几乎所有汉字 完全兼容 GB2312 依然使用 16 位（两字节） 后来国标局推出 GB18030 取代 GBK，但 GB18030 不兼容 GB2312    网页里有藏文、泰文\n怎么办，显示不了\n  简单，继续编号\n这回，一次解决全世界的需求\n  万国码 Unicode\n  优点\n已收录 13 万字符（大于 16 位），全世界通用\n以后还会继续扩充，不会停止\n最新版只添加了一个字——令和的合体字\n  缺点\n两个字节不够用，每个字符要用三个及以上字节\n这样所有文件都扩大 50%，不划算\n那怎么办？\n    虽然用 Unicode，但存的时候偷懒\n这样行不行\n  UTF-8 就被发明出来了\n还真行\n  鸡贼的存法\n  存储【a】\na 对应的 Unicode 编号为 97，十六进制为 61\nUnicode 直接存：000000000000000001100001\nUTF-8 偷懒存法：01100001\n三字节变一字节，比 GBK 还省\n  存储【你】\n你 对应的 Unicode 编号为 4F60\nUnicode 直接存：000000000100111101100000\nUTF-8 偷懒存法：111001001011110110100000\n还是三字节，没有省，但是字母都能省一点\n  UTF-8 中的 8 的意思是\n最少可用 8 位存一个字符\n    UTF-8 的规则\n  以【你a】为例\n11100100101111011010000001100001\n如何知道上述内容表示什么字符？\n读 8 位信息 11100100\n发现开头有 3 个 1，说明这个字符有 3 个八位\n于是再读两个 8 位信息 10111101 10100000\n前面的 10 不要，10 是表示我是跟着前面的，其他合起来，得 0100111101100000\n这就还原为 Unicode 的【你】了：000000000100111101100000\n再读 8 位信息 01100001\n发现开头是 0，说明这个字符只占 8 位\n这就还原为 Unicode 的【a】了：000000000000000001100001\n  这一点看不懂就跳过，反正不考\n以去餐馆排队为比喻即可\n    到此为止，终于搞清楚如何存字符了\n那就是编号，然后存编号\n  再问数字 1 和字符 1 的区别\n功能不同、存储形式不同\n  4. JS 中的数据类型   7种（大小写无所谓）\n数字 number\n字符串 string\n布尔 bool\n符号 symbol\n空 underfined\n空 null\n对象 object\n总结：四基两空一对象\n前六种为简单类型，object 为复杂类型\n  以下不是数据类型\n数组、函数、日期\n它们都属于 object\n  5. 数字 number   64 位浮点数\n  写法\n  整数写法\n1\n  小数写法\n0.1\n  科学计数法\n1.23e4\nbug：以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示\n(1) 小数点前的数字多于21位。例如\n1234567890123456789012\r// 1.2345678901234568e+21\r 123456789012345678901\r// 123456789012345680000\r(2) 小数点后的零多于5个。例如\n// 小数点后紧跟5个以上的零，\r// 就自动转为科学计数法\r0.0000003 // 3e-7\r // 否则，就保持原来的字面形式\r0.000003 // 0.000003\r  八进制写法（用的少）\n0123 或 00123 或 0o123\n  十六进制写法\n0x3F 或 0X3F\n  二进制写法\n0b11 或 0B11\n    特殊值\n  正 0 和负 0\n都等于 0，要严谨\neg：1/0 = Infinity、1/-0 = -Infinity\n  无穷大\nInfinity、+Infinity、-Infinity\n  无法表示的数字\nNaN（Not a Number）\neg：0/0 = NaN\n但它是一个数字（不是它不是数字，而是在人类目前的认知里，你不知道它是什么数字）\n所以 NaN !== NaN\n    64 位浮点数\n  JS 数字的存储形式\n浮点就是浮动的点，意思就是小数点会乱动\n123.456 可以表示为 1.23456e10^2\n也可以表示为 12345.6e10^-2\n  64 位存储一个 number\n符号占 1 位\n指数占 11 位（-1023~1024）\n有效数字占 52 位（开头的 1 省略）\n    范围和精度\n范围（忽略符号位）\n指数拉满、有效数字拉满，得到最大二进制数字\nNumber.MAX_VALUE: 1.7976931348623157e+308\n指数负方向拉满、有效数字最小 1，得到最小值\nNumber.MIN_VALUE: 5e-324\n  精度（有效数字）\n最多只能到 52+1 个二进制位表示有效数字\n2^53 对应的十进制是 9 后面 15 个零\n所以 15 位有效数字都能精确表示\n16 位有效数字如果小于 90 开头，也能精确表示\n9110 0000 0000 0001 就存不下来\n  6. 字符串 string   每个字符两个字节（阉割版 UTF8）\n  写法\n  单引号\n\u0026lsquo;你好\u0026rsquo;\n  双引号\n\u0026ldquo;你好\u0026rdquo;\n  反引号\n`你好`\n  注意\n引号不属于字符串的一部分，就像书名号不属于书名的一部分一样\n如果要在单引号里面包含单引号怎么办？\n    转义\n  错误写法\n\u0026#39;it\u0026#39;s ok\u0026#39;\rJS 引擎会认为 \u0026lsquo;it\u0026rsquo; 就结束了，后面的看不懂\n  正确写法\n\u0026#39;it\\\u0026#39;s ok\u0026#39;\t// 这就是转义\r\u0026#34;it\u0026#39;s ok\u0026#34;\r`it\u0026#39;s ok`\r  用另一种写法表示你想要的东西\n\\\u0026rsquo; 表示 '\n\\\u0026rdquo; 表示 \u0026quot;\n\\n 表示换行\n\\r 表示回车\n\\t 表示 tab 制表符\n\\\\ 表示 \\\n\\uFFFF 表示对应的 Unicode 字符\n\\xFF 表示前 256 个 Unicode 字符\n    多行字符串\n  如果你想要在字符串里回车\nlet s = `这样是\r可以的\r用反引号很容易做到`\r  以前没有反引号的时候\n写起来很麻烦，可以看网道教程\n    字符串的属性\n等等，对象才有属性，为什么字符串也有属性\n  为什么字符串有属性\n等学完对象才能解答\n  字符串的长度\n  string.length\n\u0026#39;123\u0026#39;.length\t// 3\r\u0026#39;\\n\\r\\t\u0026#39;.length\t// 3\r\u0026#39;\\\\\\\\\\\\\u0026#39;.length\t// 3\r\u0026#39;\u0026#39;.length\t// 0\r\u0026#39; \u0026#39;.length\t// 1\r    通过下标读取字符\n  string[index]\nlet s = \u0026#39;hello\u0026#39;;\rs[0]\t// \u0026#34;h\u0026#34;\r  注意 index 从 0 开始\ns[0] 是第一个字符\n  注意 index 到 length\nlet s = \u0026#39;hello\u0026#39;;\rs[5]\t// undefined,居然不报错\rs[4]\t// \u0026#39;o\u0026#39;\r    base64 转码\n  window.btoa\n正常字符串转为 Base64 编码的字符串\n  window.atob\nBase64 编码的字符串转为原来的字符串\n  一般用来隐藏招聘启事里的简历\n邮箱：MTMyMDU0MzkyMUBxcS5jb20=\n  有时候也用来自欺欺人\n所谓的【加密】，也就能骗过一部分外行\n    7. 布尔 boolean   真或假\n  只有两个值\ntrue 和 false，注意大小写\n  下列运算符会得到 bool 值\n  否定运算\n!value\n  相等运算\n1 == 2、1 != 2、3 === 4、3 !== 4\n  比较运算\n1 \u0026gt; 2、1 \u0026gt;= 2、3 \u0026lt; 4、3 \u0026lt;= 4\n    if 配 bool\n  if 语句常常需要判断真假\nif (value) {\r...\r} else {\r...\r}\r  问题来了\n如果 value 是 bool 值还好说\n如果 value 不是 bool 值咋办，谁真谁假\n1 是真还是假，0 是真还是假\n\u0026lsquo;1\u0026rsquo; 是真还是假，\u0026lsquo;0\u0026rsquo; 是真还是假\n  五个 falsy 值\nfalsy 就是相当于 false 但又不是 false 的值\n分别是 undefined\tnull\t0\tNaN\t'\u0026rsquo;\n所以 1 是真，0 是假，\u0026lsquo;1\u0026rsquo; 是真，\u0026lsquo;0\u0026rsquo; 是真\n再次声明，\u0026rsquo;\u0026rsquo; 和 ' ' 不是一个玩意，请保持严谨\n    8. 符号 symbol  不怎么常用的数据类型 直接参考文章  9. undefined 和 null 两种空类型   空空如也\n  为什么有两个空\n这是 JS 的原 (la) 创 (ji) 之处\n  区别\n  没有本质区别\n  细节一\n如果一个变量声明了，但没有赋值，那么默认值就是 undefined，而不是 null\n  细节二\n如果一个函数，没有写 return，那么默认 return undefined，而不是 null\n  细节三\n前端程序员习惯上，把非对象的空值写为 undefined，把对象的空值写为 null\n但仅仅是习惯上而已\n    10. 变量声明   三种声明方式\nvar a = 1\nlet a = 1\nconst a = 1\na = 1\n  区别\nvar 是过时的、不好用的方式\nlet 是新的，更合理的方式\nconst 是声明时必须赋值，且不能更改的方式\n最后这种方式是错误的，不准这样声明\n  var 变量提升\n后面再说，可以提前看网道教程\n  var 声明\n  直接跳过\n写代码不用 var\n后面再单独说\n    let 声明\n  规则\n遵循块作用域，即使用范围不能超出 {}\n不能重复声明\n可以赋值，也可以不赋值\n必须先声明再使用，否则报错\n全局声明的 let 变量，不会变成 window 的属性\nfor 循环配合 let 有奇效\n    const 声明\n  规则\n跟 let 几乎一样\n只有一条不一样：声明时就要赋值，赋值后不能改\n当然也不能配合 for 循环使用，因为这样会导致值被修改而报错\n    变量声明\n  指定值\nvar a = 1\n  同时也指定了类型\nvar a = 1\n  但是值和类型都可以随意变化\na = 2\na = \u0026lsquo;字符串\u0026rsquo;\n    name 和 \u0026lsquo;name\u0026rsquo; 的区别\n  name 是变量\n值可变，可能是 \u0026lsquo;name\u0026rsquo;，也可能是 \u0026lsquo;hello\u0026rsquo;\n类型也可变，可能是数字，也可能是字符串\n  \u0026lsquo;name\u0026rsquo; 是字符串常量\n常量就是不变量\n\u0026lsquo;name\u0026rsquo; 只能是 \u0026lsquo;name\u0026rsquo;，不能是其他值\n    11. 类型转换   number =\u0026gt; string\nString(n)\nn + '\u0026rsquo;\n  string =\u0026gt; number\nNumber(s)\nparseInt(s) / parseFloat(s)\ns - 0\n+s\n  x =\u0026gt; bool\nBoolean(x)\n!!x\n  x =\u0026gt; string\nString(x)\nx.toString()\nbug：1.toString() 会报错，因为 JS 认为 1. 是一个小数的开始，它认为 . 后面应该加数字，当它读到 t 时就错了，应改为 (1).toString() 或 1..toString() 或 1 .toString()\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/14-js%E8%AF%AD%E6%B3%95/",
        "title": "JS语法",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.09",
        "body": "1. JS 版本   ES 6 是最低要求\n  历史版本\nES 3，IE 6 支持，总体评价：垃圾\nES 5，总体评价：还是垃圾\nES 6，大部分浏览器支持，总体评价：一半垃圾一半好\nES 2019 与 ES 6 差别不大\n  为什么说 ES 6 一半垃圾\n因为 ES 不能删除以前的特性，要兼容旧网站\n也就是说以前能运行的网站，以后都要能运行\n对比 Python 3 你就能知道兼容的好处：稳定\n  取其精华，去其糟粕\n对待 JS，这是我们的态度\n  2. 表达式与语句   表达式\n1 + 2 表达式的值为 3\nadd(1,2) 表达式的值为函数的返回值 （只有函数才有返回值）\nconsole.log 表达式的值为函数本身\nconsole.log(3) 表达式的值为多少？答：undefined\n  语句\nvar a = 1 是一个语句\n  二者的区别\n表达式一般都有值，语句可能有也可能没有\n语句一般会改变环境（声明、赋值）\n上面两句话并不是绝对的\n  3. 大小写敏感   不要写错\nvar a 和 var A 是不同的\nobject 和 Object 是不同的\nfunction 和 Function 是不同的\n具体含义后面说\n  4. 空格   大部分空格没有实际意义\nvar a = 1 和 var a=1没有区别\n加回车大部分时候也不影响\n只有一个地方不能加回车，那就是 return 后面（如果你在 return 后面不加任何东西/加了回车，它会自动帮你补充一个 undefined）\n  5. 标识符   规则\n第一个字符，可以是 Unicode 字母或 $ 或 _ 或中文\n后面的字符，除了上面所说，还可以有数字\n例如：var 9$，就会经典报错：Uncaught SyntaxError: Invalid or unexpected token，译为：没有捕获的语法错误：不合法的或者是没有被期待的字符串\n  变量名是标识符\nvar _ = 1\nvar $ = 2\nvar ______ = 6\nvar 你好 = 'hi'\n  其他标识符用到再说\n  6. 注释   规则\n// 只能注释一行代码\n/* */ 可以注释多行代码\n  写代码要多写注释——放屁\n  注释的分类\n  不好的注释\n把代码翻译成中文\n过时的注释\n发泄不满的注释\n  好的注释\n踩坑注解\n为什么代码会写得这么奇怪，遇到什么 bug\n    7. 区块 block   把代码包在一起\n{\rlet a = 1\rlet b = 2\r}\r  常常与 if / for / while 合用\n  8. if else 语句   语法\nif (表达式) {语句1} else {语句2}\n{} 在语句只有一句的时候可以省略，不建议这样做\n  变态情况\n  表达式里可以非常变态，如 a = 1\n  语句1里可以非常变态，如嵌套的 if else\n  语句2里可以非常变态，如嵌套的 if else\n  缩进也可以很变态，如面试题常常下套\na = 1\rif (a === 2)\rconsole.log(\u0026#39;a\u0026#39;)\rconsole.log(\u0026#39;a等于2\u0026#39;)\r结果是打印a等于2，因为如果你省略了{}，那么 if 只会管到第一个语句\n    最推荐使用的写法\nif (表达式) {\r语句\r} else if (表达式) {\r语句\r} else {\r语句\r}\r  次推荐使用的写法\nfunction fn(){\rif (表达式) {\rreturn 表达式\r}\rif (表达式) {\rreturn 表达式\r}\rreturn 表达式\r}\r  9. switch 语句   语法\nswitch (fruit) {\rcase \u0026#34;banana\u0026#34;:\r// ...\r break;\rcase \u0026#34;apple\u0026#34;:\r// ...\r break;\rdefault:\r// ...\r}\r  break\n大部分时候，省略 break 你就完了\n少部分时候，可以利用 break\n  示例\na = 2\rswitch (a) {\rcase 1:\rcase 3:\rconsole.log(\u0026#39;单数\u0026#39;);\rbreak;\rcase 2:\rcase 4:\rconsole.log(\u0026#39;双数\u0026#39;);\rbreak;\r}\r结果是打出双数\n  10. 问号冒号表达式   语法\n表达式1 ? 表达式2 : 表达式3\r  示例\nfunction max(a,b) {\rreturn a\u0026gt;b ? a : b;\r}\r等价于\nfunction max(a,b) {\rif (a\u0026gt;b) {\rreturn a;\r} else {\rreturn b;\r}\r}\r  11. \u0026amp;\u0026amp; 短路逻辑   A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \u0026amp;\u0026amp; D 取第一个假值或 D\n并不会取 true / false\n  示例\nwindow.f1 \u0026amp;\u0026amp; console.log(\u0026#39;f1存在\u0026#39;)\r等价于\nif (window.f1) {\rconsole.log(\u0026#39;f1存在\u0026#39;)\r}\r  12. || 短路逻辑   A || B || C || D 取第一个真值或 D\n并不会取 true / false\n  示例\na = a || 100\r等价于\nif (a) {\ra = a;\r} else {\ra = 100;\t//保底值\r}\r  13. while 循环   语法\nwhile (表达式) {语句}\n判断表达式的真假\n当表达式为真，执行语句，执行完再判断表达式的真假\n当表达式为假，执行后面的语句\n  其他\ndo\u0026hellip;while 用得不多，自行了解\n  变态示例\nvar a = 0.1;\rwhile (a !== 1) {\rconsole.log(a);\ra = a + 0.1;\r}\r会造成死循环，原因是浮点数不精确造成的\n  14. for 循环   语法糖\nfor 是 while 循环的方便写法\n方便在哪？答：while 循环的四条语句一条都不能省略，否则会陷入死循环\n  语法\nfor (语句1;表达式2;语句3) {\r循环体\r}\r先执行语句1\n然后判断表达式2\n如果为真，执行循环体，然后执行语句3\n如果为假，直接退出循环，执行后面的语句\n  变态示例\nfor (var i = 0; i \u0026lt; 5; i++) {\rsetTimeout(()=\u0026gt;{\rconsole.log(i)\r},0)\r}\r结果是打印5次5\n但如果把 var 改成 let ，居然会正常打印 0，1，2，3，4。原因是因为 for 循环在 let 的时候会有单独的逻辑，专门满足傻子的幻想\n  15. break 和 continue  退出当前所有循环 V.S. 退出当前一次循环 如果存在多重循环，不带参数的 break 语句和 continue 语句都只针对最内层循环。  16. label 语句   语法\nfoo: {\rconsole.log(1);\rbreak foo;\rconsole.log(\u0026#39;本行不会输出\u0026#39;);\r}\rconsole.log(2);\rfoo 代表标识符\n  面试示例\n{\ra: 1\r}\rQ：上面的东西是什么？\nA：首先这个东西不是一个对象，它是一个代码块，里面有个标签 a，a 的语句就只有一个 1\nQ：如何把它变成一个对象？\nvar b = {\ra: 1\r}\r  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/13-%E5%86%85%E5%AD%98%E5%9B%BE%E4%B8%8Ejs%E4%B8%96%E7%95%8C/",
        "title": "内存图与JS世界",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.08",
        "body": "1. 操作系统常识   一切都运行在内存里\n  开机\n操作系统在 C 盘里（macOS 的在根目录下多个目录里）\n当你按下开机键，主板通电，开始读取固件\n固件就是固定在主板上的存储设备，里面有开机程序\n开机程序会将文件里的操作系统加载到内存中运行\n  操作系统（以 Linux 为例）\n首先加载操作系统内核\n然后启动初始化进程，编号为1，每个进程都有编号\n启动系统服务：文件、安全、联网\n等待用户登录：输入密码登录 / ssh 登录\n登录后，运行 shell，用户就可以和操作系统对话了\nbash 是一种 shell，图形化界面可认为是一种 shell\n    打开浏览器\n  chrome.exe\n你双击 Chrome 图标，就会运行 chrome.exe 文件\n开启 Chrome 进程，作为主进程\n主进程会开启一些辅助进程，如网络服务、GPU 加速\n你每新建一个网页，就有可能会开启一个子进程\n  浏览器的功能\n发起请求，下载 HTML，解析 HTML，下载 CSS，解析 CSS，渲染界面，下载 JS，解析 JS，执行 JS 等\n功能模块：用户界面、渲染引擎、JS 引擎、存储等\n上面功能模块一般各处于不同的线程（比进程更小）\n如果进程是车间，那么线程就是车间的流水线\n    JS 引擎\n  JS 引擎举例\nChrome 用的是 V8 引擎，C++ 编写\n网景用的是 SpiderMonkey，后被 Firefox 使用，C++\nSafari 用的是 JavaScriptCore\nIE 用的是 Chakra（JScript9）\nEdge 用的是 Chakra（JavaScript）\nNode.js 用的是 V8 引擎\n  主要功能\n编译：把 JS 代码翻译为机器能执行的字节码或机器码\n优化：改写代码，使其更高效\n执行：执行上面的字节码或者机器码\n垃圾回收：把 JS 用完的内存回收，方便之后再次使用\n    执行 JS 代码\n  准备工作\n提供 API：window / document / setTimeout\n没错，上面这些东西都不是 JS 自身具备的功能\n我们将这些功能称为运行环境 runtime env\n一旦把 JS 放进页面，就开始执行 JS\n  等一下\nJS 代码在哪里运行？\n答：内存\n哪里的内存？\n答：如下\n    2. 内存图   瓜分内存\n  红色区域\n  作用\n红色专门用来存放数据，我们目前只研究该区域\n红色区域并不存变量名，变量名在【不知什么区】\n每种浏览器的分配规则并不一样\n上图的区域并不完整\n我还没有画【调用栈】、【任务队列】等区域\n  Stack 和 Heap\n红色区域分为 Stack 栈和 Heap 堆\n要解释为什么叫栈和堆需要数据结构知识，后面再讲\nStack 区特点：每个数据顺序存放\nHeap 区特点：每个数据随机存放\n    Stack 和 Heap 举例\n  代码\nvar a = 1\rvar b = a\rvar person = {name:\u0026#39;frank\u0026#39;,child:{name:\u0026#39;jack\u0026#39;}}\rvar person2 = person\r  图示\n  规律\n数据分两种：非对象和对象\n非对象都存在 Stack（只有数字、字符串、布尔是非对象）\n对象都存在 Heap（数组、函数等）\n= 号总是会把右边的东西复制到左边（不存在什么传值和传址）\n区分值和地址（不会画内存图的人才需要做这件事）\n  对象被篡改了\n代码\nvar person = {name:\u0026#39;frank\u0026#39;}\rvar person2 = p\rp2.name = \u0026#39;ryan\u0026#39;\rconsole.log(p.name) //\u0026#39;ryan\u0026#39;\r    3. JS 世界   盘古开天辟地之前，神说要有光，就有了光\nJS 开发者说要有 window，就有了 window（浏览器提供）\n  还要什么\n  要有 console\n于是就有了 console，并且挂到 window 上\n  要有 document\n于是就有了 document，并且挂到 window 上\n  要有对象\n于是就有了 Object，并且挂到 window 上\nvar person = {} 等价于 var person = new Object()\n  要有数组（一种特殊的对象）\n于是就有了 Array，并且挂到 window 上\nvar a = [1,2,3] 等价于 var a = new Array(1,2,3)\n  要有函数（一种特殊的对象）\n于是就有了 Function，并且挂到 window 上\nfunction f(){} 等价于 var f = new Function()\n    题外话\nQ：为什么有 var a = []，还要提供 var a = new Array() 写法呢？\nA：因为后者是正规写法，但是没人用。前者不正规，但是好用啊。\nQ：为什么有 function f(){}，还要提供 var f = new Function 写法呢？\nA：原因同上\n  怎么什么都挂在 window 上\n因为方便，挂在 window 上的东西可以在任何地方直接用\n把 window 用内存图画出来\n更简单的画法\n  细节\n  关于 window\nwindow 变量和 window 对象是两个东西\nwindow 变量是一个容器，存放 window 对象的地址\nwindow 对象是 Heap 里的一坨数据\n不信的话，可以让 var x = window，那么这个 x 就指向了 window 对象，window 变量可以去死了\n但是这样的代码会弄晕新手，所以不要这样写\n  同理\nconsole 和 console 对象不是同一个东西\nObject 和 Object 函数对象不是同一个东西\n前者是内存地址，后者是一坨内存\n  一般来说，如果第一个字母是大写的，那它就会有 prototype 属性\n  用一个特殊的API：console.dir()可以打出括号内的结构，例如：\n    JS 三座大山\n1.this\n2.原型\n3.AJAX\n  4. 原型链   图里的 prototype 是干什么用的\n  打印出来看看\nconsole.dir(window.Object.prototype)，当然，window. 可以省略\n看起来就是一些无用的函数，毫无用处啊\n  思考一个问题\n  代码\nvar obj = {}\robj.toString()\rvar arr = [1,2,3]\rarr.join(\u0026#39;-\u0026#39;)\r为什么不报错？为什么可以运行？\n  画图解释\nobj 有一个隐藏属性（暂定为 fuck）\n隐藏属性存储了 Object.prototype 对象的地址\nobj.toString() 发现 obj 上没有 toString\n就去隐藏属性对应的对象里面找\n于是就找到了 Object.prototype.toString\narr 同理\n    再思考一个问题\n  代码\nvar obj = {}\robj.toString()\rvar obj2 = {}\robj2.toString()\robj 和 obj2 有什么联系？\n  画图解释（对象被篡改了）\n结论：一层是可以篡改的，两层是没有简单的办法篡改的，除非通过隐藏属性 fuck 来篡改\n  相同点\n都可以调用 .toString()\n  不同点\n地址不同 obj !== obj2\n可以拥有不同的属性\n    XXX.prototype 存储了 XXX 对象的共同属性\n这就是原型\n  这有什么好处\n如果没有原型会怎样\n  如果没有原型\n  声明一个对象\nvar obj = {\rtoString: window.Object.prototype.toString,\rhasOwnPropertyOf: window.Object......\r}\robj.toString()\rvar obj2 = {\rtoString: window.Object.prototype.toString,\rhasOwnPropertyOf: window.Object......\r}\robj2.toString()\r  你是不是想累死自己\n好让我帮你还你的蚂蚁花呗\n    原型让你无需重复声明共有属性\n省代码，省内存\n  每个对象都有一个隐藏属性\n指向原型（对象）\n  我们只关心小写对象的隐藏属性，不关心首字母大写对象的隐藏属性\n  如果没有这个隐藏属性\n那 obj 特么怎么知道自己的共有属性在哪\n  这个隐藏属性叫什么\n__proto__\n  prototype 和 __proto__ 区别是什么\n都存着原型的地址\n只不过 prototype 挂在函数上\n__proto__ 挂在每个新生成的对象上\n  思考最后一个问题\n  代码\narr.hasOwnPropertyOf()\r如果调用之，该去哪里找呢？\n  画图解释\n    ​\n"
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/12-js%E6%A6%82%E8%BF%B0/",
        "title": "JS概述",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.07",
        "body": "1. JavaScript 的诞生   布莱登临危受命\n公司要求给浏览器添加一个脚本功能\n公司要求这个脚本必须蹭 Java 的流量\n布莱登花十天设计了 JS 的最初版本（不是实现）\n  JS 的命名\nMocha 摩卡 =\u0026gt; LiveScript =\u0026gt; JavaScript\nJava 既是编程语言，也是一种咖啡\n浏览器一开始同时就支持 Java 和 JavaScript\n后来，JS 胜了（在浏览器上）\n  2. ECMAScript 标准的制定   时间\n1997 年 6 月，第一版 ECMAScript 发布\n1999 年 12 月，第三版发布，这个版本使用最广\n第四版，流产\n2009 年 12 月，第五版发布，增加了一些功能\n2015 年 6 月，第六版发布，新浏览器都支持这一版\n之后每年发布一版，版本号以年份命名\n  JS 与 ECMAScript 的关系\nECMAScript 是纸上的标准，JS 是浏览器的实现\n纸上标准往往落后于浏览器，先实现，再写进标准\n  3. JavaScript 的兴起   杀手级应用 Gmail\n2004 年愚人节，谷歌发布 Gmail 在线网页\n当时的人们认为网页只能用来看新闻和图片\nGmail 的发布让用户和开发者眼前一亮\n2005 年，Jesse 将谷歌用到的技术命名为 AJAX\n从此，前端技术正式出现\n在此之前的网页开发都是由后端和设计师完成\n2006 年，JQuery 发布，是目前最长寿的 JS 库\n后来的十年，JQuery 大放异彩，直到 IE 不行了，JQuery 才稍微没有那么火\n  4. JavaScript 的爆发   V8 快如闪电\nChrome 的 JS 引擎叫做 V8（V1 到 V7 是啥）\n2009 年，Ryan 基于 V8 创建了 Node.js\n2010 年，Isaac 基于 Node.js 写出了 npm\n前端工程师可以在浏览器之外执行 JS 了，Node.js 快速风靡\n同年，TJ 受 Sinatra 启发，发布了 Express.js\n从此，前端工程师可以愉快地写后端应用了\n  爆发\n这期间出来的技术太多，以后慢慢介绍：gulp、grunt、yeoman、requirejs、webpack、Angular、React、Vue 等\n这些技术很多也已经过时了\n  5. 总结   JS 是历史的选择\n一开始浏览器支持很多东西：Java、Flash、VBScript\n只有 JS 活到最后\n  JS 的低开高走\n一开始 JS 就是一个玩具语言\n但是 JS 每次都走对了风口\n  学习 JS 时需要注意\n旧的、过时的东西了解就好，考前记忆一些\n跟 IE 相关的知识一律忽略\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/11-%E6%B5%85%E6%9E%90url/",
        "title": "浅析URL",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.06",
        "body": "1. IP   Internet Protocal主要约定了两件事：\n 如何定位一台设备 如何封装数据报文，以跟其他设备交流    只要你在互联网中，你就有至少一个独特的 IP\n  IP 分为内网和外网\n  如何获取外网 IP\n 你从电信租用带宽，一年一千多 你买了一个路由器，然后用电脑和手机分别连接路由器广播出来的无线 WIFI 只要路由器连上电信的服务器，那么路由器就会有一个【外网 IP 】，比如【14.17.32.211】就是一个外网 IP 。这就是你在互联网中的地址 但是如果你重启路由器，那么你很有【可能】被重新分配一个【外网 IP】，也就是说你的路由器没有【固定的外网 IP】 但是有个问题，你的路由器的外网 IP 如果是【14.17.32.211】，那么你的手机和电脑的 IP 又是什么呢？答案是【内网 IP】    内网 IP\n 路由器会在你家里创建一个内网，内网中的设备使用内网 IP，一般来说这个 IP 的格式都是 【192.168.xxx.xxx】 一般路由会给自己分配一个好记的内网 IP，如【192.168.1.1】 然后路由会给每一个内网中的设备分配一个不同的内网 IP，如电脑是【192.168.1.2】，手机是【192.168.1.3】，以此类推    路由器的功能\n 现在路由器有两个 IP，一个外网 IP 和一个内网 IP 内网中的设备可以互相访问，但是不能直接访问外网 内网设备想要访问外网，就必须经过路由器中转 外网中的设备可以互相访问，但是无法访问你的内网 外网设备想要把内容送到内网，也必须通过路由器 也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器 所以路由器有时候也被叫做【网关】    几个特殊的 IP\n  【127.0.0.1】表示自己\n  【localhost】通过 hosts 指定为自己\n在 Windows 系统中，hosts 文件位于 C:\\Windows\\System32\\drivers\\etc\\hosts，它可 以让任何字符串变成一个对应的 IP，比如把hosts文件以管理员身份运行后添加 127.0.0.1 fuck，就可以用 fuck 来表示自己\n  【0.0.0.0】不表示任何设备\n    IP 有了，还需要什么？\n需要端口\n  2. 端口   一台机器可以提供很多服务\n每个服务一个号码，这个号码就叫端口号 port\n  一个比喻\n 麦当劳提供两个窗口，一号快餐，二号咖啡 你去快餐窗口点咖啡会被拒绝，让你去另一个窗口 你去咖啡窗口点快餐结果一样    一台机器可以提供不同服务\n 要提供 HTTP 服务最好使用 80 端口 要提供 HTTPS 服务最好使用 443 端口 要提供 FTP 服务最好使用 21 端口 一共有 65535 个端口（基本够用）    怎么知道应该用什么端口\n维基百科一个一个列出来了\n  端口使用还有什么规则\n  0 到 1023（2的10次方减1）号端口是留给系统使用的\n  你只有拥有了管理员权限后，才能使用这 1024 个端口\n  其他端口可以给普通用户使用\n  比如 http-server 默认使用 8080 端口\n如果要用其他端口呢？添加一个参数即可，$ hs -c-1 -p 1234 \n  一个端口如果被占用，你就只能换一个端口\n    总而言之\nIP 和端口缺一不可\n  3. 域名   域名就是对 IP 的别称\n  baidu.com 对应什么 IP\n$ ping baidu.com\n  qq.com 对应什么 IP\n$ ping qq.com\n  知识点\n一个域名可以对应不同 IP\n这个叫做均衡负载，防止一台机器扛不住\n一个 IP 可以对应不同域名\n这个叫做共享主机，穷开发者会这么做\n    域名和 IP 是怎么对应起来的\n通过 DNS（Domain Name System）\n  当你输入 qq.com\n  过程\n你的 Chrome 浏览器会向电信/联通提供的 DNS 服务器询问 qq.com 对应什么 IP，也可用命令$ nslookup qq.com询问\n电信/联通会回答一个 IP（具体过程很复杂，不研究）\n然后 Chrome 才会向对应 IP 的 80/443 端口发送请求\n请求内容是查看 qq.com 的首页\n  为什么是 80 或 443 端口\n服务器默认用 80 提供 http 服务\n服务器默认用 443 提供 https 服务\n你可以在开发者工具里看到具体的端口\n    题外话\n  www\nwww.baidu.com 和 baidu.com\n是同一个域名吗？不是\n  他们是什么关系\ncom 是顶级域名\nbaidu.com 是二级域名（俗称一级域名）\nwww.baidu.com 是三级域名（俗称二级域名）\n他们是父子关系\ngithub.io 把子域名 xxx.github.io 免费给你使用\n所以你应该知道 www.baidu.com 和 baidu.com 可以不是同一家公司，也可以是\nwww 是多余的吗？是的，非常多余\n    4. URL   如何请求不同的页面\n  路径可以做到\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTML\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS\n  工具\n使用 Chrome 开发者工具 Network 面板看看区别\n    同一个页面，不同内容\n  查询参数可以做到\nhttps://www.baidu.com/s?wd=hi\nhttps://www.baidu.com/s?wd=hello\n    同一个内容，不同位置\n  锚点可以做到\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS#参考书\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS#教程\n  注意\n锚点看起来有中文，实际不支持中文\n#参考书会变成#%E5%8F%82%E8%80%83%E4%B9%A6\n锚点是无法在 Network 面板看到的\n因为锚点不会传给服务器\n    URL\n协议 + 域名或 IP + 端口号 + 路径 + 查询字符串 + 锚点\n  URL 举例\n就算没写，你也应该知道端口\nHTTPS 默认端口 443\n  5. HTTP（协议）   基于 TCP 和 IP 两个协议\n  curl 命令\n  用 curl 可以发 HTTP 请求\n$ curl -v http://baidu.com\n$ curl -s -v -- https://www.baidu.com\n  理解以下概念\nurl 会被 curl 工具重写，先请求 DNS 获得 IP\n先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求\n请求内容看一眼\n响应内容看一眼\n响应结束后，关闭 TCP 连接（看不出来）\n真正结束\n  HTTP\n规定请求的格式是什么，响应的格式是什么\n    "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/10-css%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/",
        "title": "CSS常见问题汇总",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.05",
        "body": "1. 视口完整写法 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\u0026#34;\u0026gt;\r2. CSS 初始化（仅供参考） * {\rmargin: 0;\rpadding: 0;\rbox-sizing: border-box;\r}\r*::before,\r*::after {\rbox-sizing: border-box;\r}\rbody,\rbutton,\rinput,\rselect,\rtextarea {\r-webkit-font-smoothing: antialiased;\rfont: 12px/1.5 \u0026#39;Microsoft YaHei\u0026#39;, tahoma, arial, \u0026#39;Hiragino Sans GB\u0026#39;, \u0026#39;\\5b8b\\4f53\u0026#39;, sans-serif;\r/* 需更改 */\rbackground-color: #666;\r}\rh1,\rh2,\rh3,\rh4,\rh5,\rh6 {\rfont-size: 100%;\r}\r.w {\r/* 需更改 */\rwidth: 1200px;\rmargin: 0 auto;\r}\rol,\rul {\rlist-style: none;\r}\ra {\rcolor: inherit;\rtext-decoration: none;\r}\ra:hover {\r/* 需更改 */\rcolor: #c81623;\rtext-decoration: underline;\r}\rem,\ri {\rfont-style: normal;\r}\rimg {\rborder: 0;\rvertical-align: middle;\r/* 移动端 */\rmax-width: 100%;\r}\rbutton {\rcursor: pointer;\r}\rbutton,\rinput {\rborder: 0;\routline: none;\r}\rtable {\rborder-collapse: collapse;\rborder-spacing: 0;\r}\r.clearfix:after {\rvisibility: hidden;\rclear: both;\rdisplay: block;\rcontent: \u0026#34;.\u0026#34;;\rheight: 0;\r}\r.clearfix {\r*zoom: 1;\r}\r3. logo 标准写法 \u0026lt;div class=\u0026#34;logo\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;\r\u0026lt;a href=\u0026#34;index.html\u0026#34; title=\u0026#34;网易云音乐\u0026#34;\u0026gt;网易云音乐\u0026lt;/a\u0026gt;\r\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r.logo {\rwidth: 171px;\rheight: 61px;\r}\r.logo a {\roverflow: hidden;\rdisplay: block;\rwidth: 171px;\rheight: 61px;\rbackground: url(images/logo.png) no-repeat;\rtext-indent: -9999px; }\r4. 头部导航栏中间有竖线的多种写法   选择中间的 li 来模拟竖线 \u0026lt;nav class=\u0026#34;nav\u0026#34;\u0026gt;\r\u0026lt;ul class=\u0026#34;clearfix\u0026#34;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;发现音乐\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我的音乐\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我的音乐我的最爱哈哈\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r.nav {\rfloat: right;\rbackground-color: pink;\r}\r.nav li {\rfloat: left;\r}\r.nav li:nth-child(even) {\rwidth: 1px;\rheight: 16px;\rbackground-color: black;\rmargin-top: 33px;\r}\r.nav a {\rdisplay: block;\r/* height: 80px; */\rpadding: 0 20px;\rline-height: 80px;\r}\r  直接用 span 标签包裹竖线 \u0026lt;nav class=\u0026#34;nav\u0026#34;\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt;\u0026lt;span\u0026gt;|\u0026lt;/span\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;发现音乐\u0026lt;/a\u0026gt;\u0026lt;span\u0026gt;|\u0026lt;/span\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我的音乐\u0026lt;/a\u0026gt;\u0026lt;span\u0026gt;|\u0026lt;/span\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我的音乐我的最爱哈哈哈\u0026lt;/a\u0026gt;\r\u0026lt;/nav\u0026gt;\r.nav {\rfloat: right;\rbackground-color: pink;\r}\r.nav a {\rfloat: left;\rheight: 80px;\rpadding: 0 20px;\rline-height: 80px;\rtext-align: center;\rbackground-color: yellowgreen;\r}\r.nav span {\rfloat: left;\rmargin-top: 30px;\r}\r  用伪元素做一个盒子来模拟竖线，再通过绝对定位定位到后面 \u0026lt;nav class=\u0026#34;nav\u0026#34;\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;line\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;line\u0026#34;\u0026gt;发现音乐\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;line\u0026#34;\u0026gt;我的音乐\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我的音乐我的最爱哈哈哈\u0026lt;/a\u0026gt;\r\u0026lt;/nav\u0026gt;\r.nav {\rfloat: right;\rbackground-color: pink;\r}\r.nav a {\rposition: relative;\rfloat: left;\rheight: 80px;\rpadding: 0 20px;\rline-height: 80px;\rtext-align: center;\r}\r.nav .line::after {\rposition: absolute;\rright: 0;\rtop: 33px;\rcontent: \u0026#39;\u0026#39;;\rdisplay: block;\rwidth: 1px;\rheight: 16px;\rbackground-color: black;\r}\r  5. 两栏布局（以左边固定宽度，右边自适应为例） html结构均如下：\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r  利用 BFC .left {\rfloat: left;\rwidth: 200px;\rheight: 200px;\r}\r.right {\r/* overflow:hidden触发了BFC，这个独立的盒子不会和float的盒子发生重叠 */\roverflow: hidden;\rheight: 200px;\r}\r  利用 calc() 函数 .left {\rfloat: left;\rwidth: 200px;\rheight: 200px;\r}\r.right {\rfloat: left;\rheight: 200px;\r/* 操作符左右两侧最好写上空格，不然容易出错 */\rwidth: calc(100% - 200px);\r}\r  6. 三栏布局（以两边固定宽度，中间自适应为例） html 结构均如下：\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;center\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r  浮动float 核心：父元素不设置定位，三列子元素都设置为左浮动。 自适应的那一列宽度用计算得出：calc(100% - 左边宽度 - 右边宽度)。\n.left {\rfloat: left;\rwidth: 200px;\rheight: 200px;\r}\r.center {\rfloat: left;\rwidth: calc(100% - 400px);\rheight: 200px;\r}\r.right {\rfloat: left;\rwidth: 200px;\rheight: 200px;\r}\r  position定位 核心：将父元素设置为相对定位 position: relative; 左边列(固定宽度)：position: absolute; left: 0; 中间列（自适应列）：标准流 右边列（固定宽度）：position: absolute; right: 0;\n.box {\rposition: relative;\r/*父元素设置相对定位*/\rpadding: 0 200px;\r}\r.left {\rposition: absolute;\r/*子元素绝对定位*/\rtop: 0;\rleft: 0;\r/*与左边距离为0*/\rwidth: 200px;\rheight: 200px;\r}\r.center {\rheight: 200px;\r}\r.right {\rposition: absolute;\r/*子元素绝对定位*/\rtop: 0;\rright: 0;\r/*与右边距离为0*/\rwidth: 200px;\rheight: 200px;\r}\r  flex弹性盒布局 核心：将父元素设置为弹性盒布局：display: flex;\n自适应的那一列设置为 flex: 1\n.box {\rdisplay: flex;\r/*父元素设置为弹性盒*/\r}\r.left {\rwidth: 200px;\r/*宽度固定*/\rheight: 200px;\r}\r.center {\rflex: 1;\rheight: 200px;\r}\r.right {\rwidth: 200px;\r/*宽度固定*/\rheight: 200px;\r}\r  7. 绝对、固定定位且宽度不固定的盒子水平居中 html 结构均如下：\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r  核心：left: 0; right: 0; margin: 0 auto;\n.box {\rposition: absolute;\r/* position: fixed; */\rleft: 0;\rright: 0;\rtop: 0;\rmargin: 0 auto;\rmax-width: 980px;\rmin-width: 320px;\rwidth: 100%;\rheight: 200px;\r}\r  核心：left: 50%; transform: translate(-50%);\n.box {\rposition: absolute;\r/* position: fixed; */\rleft: 50%;\rtop: 0;\rmax-width: 980px;\rmin-width: 320px;\rwidth: 100%;\rheight: 200px;\rtransform: translate(-50%);\r/* 也是向左移动当前元素宽度的一半 */\r}\r  8. background-size 属性 在使用精灵图或其它背景图时我们时常遇到二倍图，需要把它缩小\n  值的个数\n  一个值\n这个值指定图片的宽度，此时图片高度默认为 auto\n  两个值\n第一个值指定图片的宽度，第二个值指定图片的高度\n    值的种类\n  auto\n背景图片与插入图片一样，会随着另一个非 auto 值的改变而等比例缩放\n  具体值（px、em等）\n背景图片把自身按照具体值大小缩放\n  百分比\n这个百分比是相对于当前盒子的大小来说的，所以背景图片按照当前盒子的宽高百分比缩放\n  contain\n缩放背景图片以完全装入容器，可能背景区部分空白。尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n  cover\n缩放背景图片以完全覆盖容器，可能背景图片部分看不见。尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。\n（比如此例我们就看不到小姐姐了呜呜呜。。。）\n    9. 持续更新中 "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/09-css%E5%8A%A8%E7%94%BB/",
        "title": "CSS动画",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.05",
        "body": "1. 动画   定义\n由许多静止的画面（帧）\n以一定的速度（如每秒30张）连续播放时\n肉眼因视觉残象产生错觉\n而误以为是活动的画面\n  概念\n帧：每个静止的画面都叫做帧\n播放速度：每秒 24 帧（影视） 或者每秒 30 帧（游戏）\n  一个最简单的例子\n  将 div 从左往右移动\n代码\n  原理\n每过一段时间（用 setInterval 做到）\n将 div 移动一小段距离\n直到移动到目标地点\n  注意性能\n绿色表示重新绘制（repaint）了\nCSS 渲染过程依次包含布局、绘制、合成\n其中布局和绘制有可能被省略\n    前端高手不用 left 做动画\n  用 transform（变形）\n代码\n  原理\ntransform: translateX(0 =\u0026gt; 300px)\n直接修改会被合成，需要等一会修改\ntransition 过渡属性可以自动脑补中间帧\n  注意性能\n并没有 relayout 以及 repaint（重新绘制）\n比改 left 性能好\n    2. 浏览器渲染原理   参考文章\n  Google 团队写的文章（右上角中文）\n渲染树构建、布局及绘制\n渲染性能\n使用 transform 来实现动画\n  查看 CSS 各属性触发什么\nCSSTriggers.com\n    浏览器渲染过程\n根据 HTML 构建 HTML 树（DOM）\n根据 CSS 构建 CSS 树（CSSOM）\n将两棵树合并成一颗渲染树（render tree）\nLayout 布局（文档流、盒模型、计算大小和位置）\nPaint 绘制（把边框颜色、文字颜色、阴影等画出来）\nComposite 合成（根据层叠关系展示画面）\n  如何更新样式\n  一般我们用 JS 来更新样式\n比如 div.style.background='red'\n比如 div.style.display='none'\n比如 div.classList.add=('red')\n比如 div.remove() 直接删掉节点\n  那么这些方法有什么不同吗\n有三种不同的渲染方式\n    三种更新方式\n  第一种，全走\ndiv.remove() 会触发当前消失，其他元素 relayout\n  第二种，跳过 layout\n改变背景颜色，直接 repaint + composite\n  第三种，跳过 layout 和 paint\n改变 transform，只需 composite\n注意必须全屏查看效果，在 iframe 里看有问题\n    CSS 动画优化\n  没什么技术含量\n答案都在Google 写的文章里，谁看完谁牛 X\n  JS 优化\n使用 requestAnimationFrame 代替 setTimeout 或 setInterval\n  CSS 优化\n使用 will-change 或 translate\n  没错\n完全就是死记硬背\n    3. transform   MDN 文档\n  四个常用功能\n位移 translate\n缩放 scale\n旋转 rotate\n倾斜 skew\n  经验\n一般都需要配合 transition 过渡\ninline 元素不支持 transform，需要先变成 block\n  transform 之 translate\n  常用写法\ntranslateX( \u0026lt;length-percentage\u0026gt; )\ntranslateY( \u0026lt;length-percentage\u0026gt; )\ntranslate( \u0026lt;length-percentage\u0026gt; , \u0026lt;length-percentage\u0026gt;? )\ntranslateZ( \u0026lt;length\u0026gt; ) 且父容器 perspective\ntranslate3d(x, y, z)\n示例\n  经验\n要学会看懂 MDN 的语法示例\ntranslate(-50%,-50%) 可做绝对定位元素的居中\n    transform 之 scale\n  常用写法\nscaleX( \u0026lt;number\u0026gt; )\nscaleY( \u0026lt;number\u0026gt; )\nscale( \u0026lt;number\u0026gt; , \u0026lt;number\u0026gt;? )\n示例\n  经验\n用的较少，因为容易出现模糊\n    transform 之 rotate\n  常用写法\nrotate( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nrotateZ( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nrotateX( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nrotateY( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nrotate3d 太复杂，无法用语言表述\n示例\n  经验\n一般用于 360 度旋转制作 loading\n用到时再搜索 rotate MDN 看文档\n    transform 之 skew\n  常用写法\nskewX( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nskewY( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] )\nskew( [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ] , [ \u0026lt;angle\u0026gt; | \u0026lt;zero\u0026gt; ]? )\n示例\n  经验\n用的较少\n用到时再搜 skew MDN 文档\n    transform 多重效果\n  组合使用\ntransform: scale(0.5) translate(-100%, -100%);\ntransform: none; 取消所有\n    4. transition   MDN 文档\n  作用\n补充中间帧\n  语法\ntransition: 属性名 时长 过渡方式 延迟\ntransition: left 200ms linear\n可以用逗号分隔两个不同属性\ntransition: left 200ms, top 400ms\n可以用 all 代表所有属性\ntransition: all 200ms\n过渡方式有：linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier | step-start | step-end | steps，具体含义要靠数学知识\n  注意\n  并不是所有属性都能过渡\ndisplay: none =\u0026gt; block 没法过渡\n一般改成 visibility: hidden =\u0026gt; visible（没有为什么）\nbackground 颜色可以过渡吗？（可以）\nopacity 透明度可以过渡吗？（可以）\n  让一个盒子消失的三种过渡方案对比，均设置为transition: all 5s;\nA. 由 display: block 过渡为 display: none\n​\t结果：盒子会在第一秒就立即消失，没有过渡效果，消失后不占位置\nB. 由 visibility: visible 过渡为 visibility: hidden\n​\t结果：盒子会在最后一秒立即消失，没有过渡效果，消失后继续占位置\nC. 由 opacity: 1 过渡为 opacity: 0\n​\t结果：盒子会慢慢变透明最终消失，有过渡效果，消失后继续占位置\n    过渡必须要有起始，如果除了起始，还有中间点，怎么办？\n两种办法\n  使用两次 transform\n.a === transform ===\u0026gt; .b\n.b === transform ===\u0026gt; .c\n如何知道到了中间点呢？\n用 setTimeout 或者监听 transitionend 事件\n示例\n  使用 animation\n声明关键帧\n添加动画\n示例\n    5. animation   @keyframes 完整语法\n  标准写法\n搜索 keyframes MDN 讲的很清楚\n一种写法是 from to\n另一种写法是百分数\n    如何让动画停在最后一帧\n搜索 css animation stop at end\n网友给出的答案是加个 forwards\n示例\n  缩写语法\nanimation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名；\n时长：1s 或者 1000ms\n过渡方式：跟 transition 取值一样，如 linear\n次数：3 或者 2.4 或者 infinite\n方向：reverse | alternate | alternate-reverse\n填充模式：none | forwards | backwards | both\n是否暂停：paused | running\n以上所有属性都有对应的单独属性\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/08-css%E5%AE%9A%E4%BD%8D/",
        "title": "CSS定位",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.05",
        "body": "1. 盒模型 Q：背景的范围是从哪到哪？（B）\n A. border 内边沿围成的区域 B. border 外边沿围成的区域 如何验证自己的猜想？border 半透明试试  Q：从左边看一个 div，是什么样子？\n2. 新属性 - position   position\nstatic 默认值，待在文档流里\nrelative 相对定位，升起来，但不脱离文档流\nabsolute 绝对定位，定位基准是祖先里的非 static\nfixed 固定定位，定位基准是 viewport （有诈）\nsticky 粘滞定位，不好描述直接举例\n  经验\n如果你写了 absolute，一般都得补一个 relative\n如果你写了 absolute 或 fixed，一定要补 top 和 left\nsticky 兼容性很差，主要用于面试装逼\n  position: relative\n  使用场景\n用于做位移 （很少用）\n用于给 absolute 元素做爸爸（子绝父相）\n  配合 z-index\nz-index: auto 默认值，不创建新层叠上下文\nz-index: 0 / 1 / 2\nz-index: -1 / -2\n  经验\n写 z-index: 9999 的都是彩笔\n学会管理 z-index\n    position: absolute\n  使用场景\n脱离原来的位置，另起一层，比如对话框的关闭按钮\n鼠标提示\n  配合 z-index\n  经验\n很多彩笔都以为 absolute 是相对于 relative 定位的\n某些浏览器上如果不写 top / left 会位置错乱\n善用 left: 100%\n善用 left: 50%; 加负 margin\n    position: fixed\n  使用场景\n烦人的广告\n回到顶部按钮\n  配合 z-index\n  经验\n不要把 fixed 的元素放到有 transform 属性的元素的里面，会产生奇怪的反应\n手机上尽量不要用这个属性，坑很多\n不信你搜索一下【移动端 fixed】\n    3. 层叠上下文 Q：z-index: 10 和 z-index: 5 哪个高？ （D）\nA. 前者高 B. 后者高 C. 一样高 D. 看情况\n  比喻\n每个层叠上下文就是一个新的小世界（作用域）\n这个小世界里面的 z-index 跟外界无关\n处在同一个小世界里的 z-index 才能比较\n例子\n  哪些不正交的属性可以创建它\nMDN 文档有写\n需要记忆的有 z-index / fixed / flex / opacity / transform\n  负 z-index 与层叠上下文\n记住负 z-index 逃不出小世界\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/07-css%E5%B8%83%E5%B1%80/",
        "title": "CSS布局",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.05",
        "body": "1. 布局分类   两种\n固定宽度布局，一般宽度为 960 / 1000 / 1024 px\n不固定宽度布局，主要靠文档流的原理来布局\n  还记得吗\n文档流本来就是自适应的，不需要加额外的样式\n  第三种布局\n响应式布局\n意思就是PC上固定宽度，手机上不固定宽度，也就是一种混合布局\n  2. float 布局   步骤\n子元素上加 float: left 和 width\n在父元素上加 .clearfix\n  经验\n有经验者会留一些空间或者最后一个不设 width\n不需要做响应式，因为手机上没有 IE ，而这个布局是专门为 IE 准备的\nIE 6/7 存在双倍 margin bug ，解决办法有两个\n 一是将错就错，针对 IE 6/7 把 margin 减半，_margin-left: 5px; 二是神来一笔，再加一个 display: inline-block    不同布局\n用 float 做两栏布局 （如顶部条）\n用 float 做三栏布局 （如内容区）\n用 float 做四栏布局 （如导航）\n用 float 做平均布局 （如产品展示区）\nQ：平均布局有一个典型的问题是需要消除每行最后一个 li 的 margin-right 的影响，假设结构是这样的：\n\u0026lt;div class=\u0026#34;w\u0026#34;\u0026gt;\r\u0026lt;ul class=\u0026#34;clearfix\u0026#34;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r.w {\rwidth: 1200px;\r}\r.w ul li {\rfloat: left;\rwidth: 228px;\rheight: 270px;\rmargin-right: 15px;\r}\r那么解决方法有三种：\n  如果 ul 没有背景色，直接把 ul 宽度变宽\n.w ul {\rwidth: 1215px;\r}\r  运用 margin 负值\n.w ul {\rmargin-right: -15px;\r}\r  清除每一行的最后一个 li 的 margin-right\n.w ul li:nth-child(5n) {\rmargin-right: 0;\r}\r    3. flex 布局   教程\nflex布局\n  记住这些代码\ndisplay: flex\nflex-direction: row / column\nflex-wrap: wrap\njustify-content: center / space-between\nalign-items: center\n工作中基本只用这些\n  不同布局\n用 flex 做两栏布局\n用 flex 做三栏布局\n用 flex 做四栏布局\n用 flex 做平均布局\n用 flex 组合使用，做更复杂的布局\n代码\n  经验\n永远不要把 width 和 height 写死，除非特殊说明\n用 min-width / max-width / min-height / max-height\nflex 可以基本满足所有需求\nflex 和 margin-xxx: auto 配合有意外的效果\n  什么叫写死\n  写死\nwidth: 100px\n  不写死\nwidth: 50%\nmax-width: 100px\nwidth: 30vw\nmin-width: 80%\n特点：不使用 px，或者加 min max 前缀\n    如何在两套布局中切换\n主要使用 @media 媒体查询\n  4. Grid 布局   二维布局用 Grid\n一维布局用 Flex\n  教程\nGrid布局\n  布局\nGrid 尤其适合不规则布局\n代码\n  经验\n等到 Grid 普及了，前端对 CSS 的要求会进一步降低\n目前简单尝试一下 Grid 就可以了\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/06-css%E6%A6%82%E8%BF%B0/",
        "title": "CSS概述",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.05",
        "body": "1. CSS层叠样式表，层叠指什么？   样式层叠\n可以多次对同一选择器进行样式声明\n  选择器层叠\n可以用不同选择器对同一个元素进行样式声明\n  文件层叠\n可以用多个文件进行层叠\n  这些特性使得CSS极度灵活\n这也为CSS后来被吐槽留下了隐患\n  2. 语法   语法一：样式语法\n选择器 {\r属性名: 属性值;\r/*注释*/\r}\r  语法二：at语法\n@charset \u0026#34;UTF-8\u0026#34;; /*声名字符编码*/\r@import url(2.css); /*导入一个额外的CSS文件*/\r@media (min-width: 100px) and (max-width: 200px) { /*媒体查询*/\r语法一\r}\r注意事项：\n @charset 必须放在第一行 前两个 at 语法必须以分号 ; 结尾 @media 语法后面填坑 charset 是字符集的意思，但 UTF-8 是字符编码encoding，这是历史遗留问题    3. 文档流 Normal Flow   文档流\n  流动方向\ninline 元素从左到右，到达最右边才会换行\nblock 元素从上到下，每一个都另起一行\ninline-block 也是从左到右，但是到达最后的时候不会把自己分成两块，不会跨两行\n  宽度\ninline 宽度为內部 inline 元素宽度的总和，不能用 width 指定\nblock 默认自动计算宽度，宽度默认值为 auto 而不是 100%，可用 width 指定，永远不要写 width: 100%\ninline-block 结合前两者特点，可用 width\n  高度\ninline 高度由 inline-height 间接确定，跟 height 、padding 无关\nblock 高度由内部文档流元素高度的总和决定，可以设 height\ninline-block 跟 block 类似，可以设置 height\ntip：当 block 里没有内容时，高度为0，但 inline 里没有内容时，高度为行高\n    overflow 溢出\n  当内容大于容器\nvisible\nhidden\nscroll\nauto\ntip：当容器有水平滚动条时，里面的 inline 元素（水平方向上）是默认只在第一屏里面显示，后面的留空，不会如上面所说到达最右边才会换行\n    4. 盒模型   请简述 CSS 盒模型是什么？\nCSS 盒模型分两种，一种是 content-box，一种是 border-box\n两者的区别是：content-box 的宽度只包含 content，border-box 的宽度包含了 border、paddding、content\n  margin 合并\n  哪些情况会合并\n兄弟 margin 合并\n父子 margin 合并（塌陷）\n  如何阻止合并\n兄弟合并是符合预期的\n兄弟合并可以用 inline-block 消除\n父子合并用 padding / border 挡住\n父子合并用 overflow: hidden 挡住\n父子合并用 display: flex\n    "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/05-html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/",
        "title": "HTML重点标签",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.02",
        "body": "1. a 标签的用法   href\n取值：\n  网址\nhttps://google.com\nhttp://google.com\n//google.com 最高级，它会自动选择是用https还是http\n  路径\n/a/b/c 以及 a/b/c 注意绝对路径开头的/是指http-server的根目录，而不是指硬盘的根目录\nindex.html 以及 ./index.html\n  伪协议\njavascript:代码; 用法：当你想点击一个a链接什么都不做的话，就让href=\u0026quot;javascript:;\u0026quot;\n​ 那如果href=\u0026quot;\u0026quot;呢？结果是点击这个a链接页面会刷新\n​ 那如果href=\u0026quot;#\u0026quot;呢？结果是点击这个a链接页面会自动滚到顶部\nmailto:邮箱 会自动跳转到发邮件的界面，并自动填写mailto后面的邮箱\ntel:手机号 会自动跳转到拨号的界面，并自动填写tel后面的手机号\n  id\n#xxx 锚点链接，页面会跳转到指定的标签\n    target\n取值：\n（1）内置名字：\n _blank _self _top 如果有多级窗口，就在最顶级的窗口打开 _parent 如果有多级窗口，就在其父级窗口打开  （2）程序员命名：\n  window的name,比如xxx\n如果有一个叫xxx的窗口，就用它，如果没有呢，就创建一个窗口，把它叫作xxx\n  iframe的name\n    download\n下载页面。但不是所有浏览器都支持，尤其是手机浏览器不支持\n  rel=noopener\n为了防止一个bug，等学了JS后再回来填坑\n  2. iframe 标签 ​　内嵌窗口，页面可以通过iframe引用另一个页面，需要注意的是google是不允许别人用iframe指向它的。不过已经很少使用了，还有些老系统在用。\n3. table 标签的用法   简单的表格\n\u0026lt;table\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;英语\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;翻译\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;hyper\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;超级\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;target\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;目标\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;reference\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;引用\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;tfoot\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;空\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;空\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tfoot\u0026gt;\r\u0026lt;/table\u0026gt;\r  两个表头的表格\n\u0026lt;table\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;小红\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;小明\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;小颖\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;数学\u0026lt;/th\u0026gt;\r\u0026lt;td\u0026gt;61\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;91\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;85\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;语文\u0026lt;/th\u0026gt;\r\u0026lt;td\u0026gt;79\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;82\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;92\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;英语\u0026lt;/th\u0026gt;\r\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;97\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;87\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;tfoot\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;总分\u0026lt;/th\u0026gt;\r\u0026lt;td\u0026gt;200\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;200\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;200\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tfoot\u0026gt;\r\u0026lt;/table\u0026gt;\r  相关的样式\n  table-layout\nauto 表格及单元格的宽度取决于其包含的内容\nfixed 表格及单元格的宽度尽量平均\n  border-collapse\n  border-spacing\n    5. img 标签的用法   作用\n发出 get 请求，展示一张图片\n  属性\nalt / height / width / src\n  事件\nonload / onerror\n  响应式\nmax-width:100%\n  可替换元素\n  6. form 标签的用法   作用\n发 get 或 post 请求，然后刷新页面\n  属性\n action 控制请求哪个页面 method 控制请求方式是用GET还是POST autocomplete 控制是否自动填充，on/off target 和a链接的 target 用法相同，告诉浏览器我要提交到哪个页面，哪个页面需要刷新    事件\nonsubmit\nQ：\u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;搞起\u0026quot; /\u0026gt;与\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;搞起\u0026lt;/button\u0026gt; 有什么区别？\nA：input里面不能再放其它标签，只能有纯文本，而button里面可以有任何标签\n  7.input 标签的用法   作用\n让用户输入内容\n  属性\n 类型 type: button / checkout / email / file / hidden / number / password / radio / search / submit / tel / text 其它: name / autofocus / checked / disabled / maxlength / pattern / value / palceholder    事件\nonchange / onfocus / onblur\n  验证器\nHTML5 新增功能\n  注意事项：一般不监听 input 的 click 事件\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/04-html%E6%A6%82%E8%BF%B0/",
        "title": "HTML概述",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.02",
        "body": "1. HTML历史 HTML是在1990年左右诞生,由英国人Tim Berners-Lee发明，与此同时他还发明了HTTP和URL，与HTML共同组成了WWW（万维网）\n2. HTML起手应该写什么 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!-- 声明文档类型为html --\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;!-- 声明语言为中文-中国 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!-- 声明字符集为UTF-8 --\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;!-- 声明视口禁用缩放，以兼容手机 --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;!-- 声明如果当前页面在IE浏览器里显示，IE请升级成最新的内核 --\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- 页面标题 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3. 常用的章节标签  标题 h1~h6 章节 section 文章 article 段落 p 头部 header 脚部 footer 主要内容 main 旁支内容 aside 划分 div  4. 全局属性   class——给标签分一个类\n  contenteditable——使任何一个元素可以被编辑\n  hidden——快速让一个东西看不见\n  id——给标签一个名字，这个名字有两个作用，其一在CSS中加#来添加样式，其二在JS中直接通过id获取到对应的元素\n通常我们的理解是：如果这个元素是全页面唯一的，就用id,如果不是全页面唯一的，就用class。其实这个理解是错误的，不到万不得已，千万不要用id，因为id重复了不会报错，并且id名是有忌讳的（打开控制台输入window.里面所列的所有单词都不能用，例如parent、top、self等，因为它们已经是window已经有的全局属性，你不可能通过一个标签把这个全局属性覆盖了，这里的不能用是指虽然可以起这个id名，但JS就没法通过id找到它）\n  style——给标签添加样式\n  tabindex——用来控制tab的顺序，可以取值-1,0,1,2,3\u0026hellip;，正整数表示按照从小到大顺序访问,0表示最后访问，-1表示别访问我\n  title——用来显示完整的内容\n  5. 常用的内容标签  ol+li ul+li dl+dt+dd pre——双标签，把需要保留空格、回车、以及tab缩进的内容包起来即可 code——内联元素，用来包裹代码块，默认样式为里面的字是等宽的，搭配pre使用效果更佳 hr br a em——语气上的强调很重要 strong——内容本身就很重要 q——内联引用，没有样式改变，只是有引用的语义 blockquote——块级引用  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/03-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",
        "title": "如何用hugo搭建个人博客",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.01",
        "body": "首先这是hugo官方教程，当然如果你不喜欢看英文的话，那就往下看我的教程吧\n  安装hugo  在https://github.com/gohugoio/hugo/releases里下载安装包并解压\n验证安装，显示版本号即安装成功\n$ hugo version   建立新网站　 将quickstar替换为你用于存放和上传博客的本地仓库的文件夹名称\n$ hugo new site quickstart   添加主题　 首先，从Github下载默认主题并将其添加到您网站的theme目录中\n$ cd quickstart $ git init $ git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中\n$ echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml   开始写博客 首先创建一个新.md文件\n$ hugo new posts/my-first-post.md 新创建的文件会从以下内容开始\n--- $ title: \u0026quot;My First Post\u0026quot; $ date: 2019-03-26T08:47:11+01:00 $ draft: true --- 这里要注意写完博客后要把draft: true修改为draft: false，因为draft是草稿的意思\n  启动Hugo服务器 $ hugo server -D | EN +------------------+----+ Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 3 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Total in 11 ms Watching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes} Watching for config changes in /Users/bep/quickstart/config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop Ctrl+C即可进入预览页面http://localhost:1313/，在本地的md文档中随意编辑或添加新内容，只需在浏览器中刷新即可快速查看更改\n  自定义主题 对网站进行一些配置,在文本编辑器中打开config.toml\nbaseURL = \u0026quot;https://example.org/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot; theme = \u0026quot;ananke\u0026quot; 其中:\nlanguageCode = \u0026quot;zh-Hans\u0026quot; 网站语言设置为中文\ntitle和theme可以自行更改,更多主题请访问https://themes.gohugo.io/\n  建立静态页面 $ hugo -D 此时在quickstart下面会生成一个public文件夹,表示搭建成功\n  完结撒花 之后你就能通过git和Github完成个人博客的修改以及上传啦\n  "
    }
,
    {
        "ref": "http://dongshuaizhi.top/blog/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/",
        "title": "开博大吉",
        "section": "blog",
        "tags": null,
        "date" : "2020.04.01",
        "body": "大家好，我的博客开通啦！\n"
    }
]
